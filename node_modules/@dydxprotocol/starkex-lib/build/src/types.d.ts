import BN from 'bn.js';
import elliptic from 'elliptic';
export declare enum NetworkId {
    MAINNET = 1,
    ROPSTEN = 3
}
export declare enum StarkwareOrderType {
    LIMIT_ORDER_WITH_FEES = "LIMIT_ORDER_WITH_FEES"
}
export declare enum StarkwareOrderSide {
    BUY = "BUY",
    SELL = "SELL"
}
export declare enum DydxMarket {
    BTC_USD = "BTC-USD",
    ETH_USD = "ETH-USD",
    LINK_USD = "LINK-USD",
    AAVE_USD = "AAVE-USD",
    UNI_USD = "UNI-USD",
    SUSHI_USD = "SUSHI-USD",
    SOL_USD = "SOL-USD",
    YFI_USD = "YFI-USD",
    ONEINCH_USD = "1INCH-USD",
    AVAX_USD = "AVAX-USD",
    SNX_USD = "SNX-USD",
    CRV_USD = "CRV-USD",
    UMA_USD = "UMA-USD",
    DOT_USD = "DOT-USD",
    DOGE_USD = "DOGE-USD",
    MATIC_USD = "MATIC-USD",
    MKR_USD = "MKR-USD",
    FIL_USD = "FIL-USD",
    ADA_USD = "ADA-USD",
    ATOM_USD = "ATOM-USD",
    COMP_USD = "COMP-USD",
    BCH_USD = "BCH-USD",
    LTC_USD = "LTC-USD",
    EOS_USD = "EOS-USD",
    ALGO_USD = "ALGO-USD",
    ZRX_USD = "ZRX-USD",
    XMR_USD = "XMR-USD",
    ZEC_USD = "ZEC-USD",
    ENJ_USD = "ENJ-USD",
    ETC_USD = "ETC-USD",
    XLM_USD = "XLM-USD",
    TRX_USD = "TRX-USD",
    XTZ_USD = "XTZ-USD",
    HNT_USD = "HNT-USD"
}
export declare enum DydxAsset {
    USDC = "USDC",
    BTC = "BTC",
    ETH = "ETH",
    LINK = "LINK",
    AAVE = "AAVE",
    UNI = "UNI",
    SUSHI = "SUSHI",
    SOL = "SOL",
    YFI = "YFI",
    ONEINCH = "1INCH",
    AVAX = "AVAX",
    SNX = "SNX",
    CRV = "CRV",
    UMA = "UMA",
    DOT = "DOT",
    DOGE = "DOGE",
    MATIC = "MATIC",
    MKR = "MKR",
    FIL = "FIL",
    ADA = "ADA",
    ATOM = "ATOM",
    COMP = "COMP",
    BCH = "BCH",
    LTC = "LTC",
    EOS = "EOS",
    ALGO = "ALGO",
    ZRX = "ZRX",
    XMR = "XMR",
    ZEC = "ZEC",
    ENJ = "ENJ",
    ETC = "ETC",
    XLM = "XLM",
    TRX = "TRX",
    XTZ = "XTZ",
    HNT = "HNT"
}
export declare type SyntheticAsset = Exclude<DydxAsset, DydxAsset.USDC>;
export interface KeyPair {
    publicKey: string;
    publicKeyYCoordinate?: string;
    privateKey: string;
}
export interface KeyPairWithYCoordinate extends KeyPair {
    publicKeyYCoordinate: string;
}
export interface SignatureStruct {
    r: string;
    s: string;
}
export declare type HashFunction = (a: BN, b: BN) => BN | Promise<BN>;
export declare type SigningFunction = (key: elliptic.ec.KeyPair, message: BN) => elliptic.ec.Signature | Promise<elliptic.ec.Signature>;
export declare type VerificationFunction = (key: elliptic.ec.KeyPair, message: BN, signature: SignatureStruct) => boolean | Promise<boolean>;
interface WithdrawalParamsBase {
    positionId: string;
    humanAmount: string;
    expirationIsoTimestamp: string;
}
interface WithClientId {
    clientId: string;
    nonce?: undefined;
}
interface WithNonce {
    clientId?: undefined;
    nonce: string;
}
export declare type WithdrawalWithClientId = WithdrawalParamsBase & WithClientId;
export declare type WithdrawalWithNonce = WithdrawalParamsBase & WithNonce;
export interface StarkwareWithdrawal {
    positionId: string;
    quantumsAmount: string;
    nonce: string;
    expirationEpochHours: number;
}
export interface TransferParams {
    senderPositionId: string;
    receiverPositionId: string;
    receiverPublicKey: string;
    humanAmount: string;
    clientId: string;
    expirationIsoTimestamp: string;
}
export interface ConditionalTransferParams extends TransferParams {
    factRegistryAddress: string;
    fact: string;
}
export interface StarkwareTransfer {
    senderPositionId: string;
    receiverPositionId: string;
    receiverPublicKey: string;
    quantumsAmount: string;
    nonce: string;
    expirationEpochHours: number;
}
export interface StarkwareConditionalTransfer extends StarkwareTransfer {
    condition: string;
}
interface OrderParamsBase {
    positionId: string;
    humanSize: string;
    limitFee: string;
    market: DydxMarket;
    side: StarkwareOrderSide;
    expirationIsoTimestamp: string;
}
export interface WithPrice {
    humanPrice: string;
    humanQuoteAmount?: undefined;
}
export interface WithQuoteAmount {
    humanPrice?: undefined;
    humanQuoteAmount: string;
}
export declare type OrderWithClientId = OrderParamsBase & WithPrice & WithClientId;
export declare type OrderWithNonce = OrderParamsBase & WithPrice & WithNonce;
export declare type OrderWithClientIdAndQuoteAmount = OrderParamsBase & WithQuoteAmount & WithClientId;
export declare type OrderWithNonceAndQuoteAmount = OrderParamsBase & WithQuoteAmount & WithNonce;
export interface StarkwareAmounts {
    quantumsAmountSynthetic: string;
    quantumsAmountCollateral: string;
    assetIdSynthetic: string;
    assetIdCollateral: string;
    isBuyingSynthetic: boolean;
}
export interface StarkwareOrder extends StarkwareAmounts {
    orderType: StarkwareOrderType;
    quantumsAmountFee: string;
    assetIdFee: string;
    positionId: string;
    nonce: string;
    expirationEpochHours: number;
}
export declare enum ApiMethod {
    POST = "POST",
    PUT = "PUT",
    GET = "GET",
    DELETE = "DELETE"
}
export interface ApiRequestParams {
    isoTimestamp: string;
    method: ApiMethod;
    requestPath: string;
    body: string;
}
export interface OraclePriceWithAssetName {
    assetName: string;
    oracleName: string;
    humanPrice: string;
    isoTimestamp: string;
}
export interface OraclePriceWithMarket {
    market: DydxMarket;
    oracleName: string;
    humanPrice: string;
    isoTimestamp: string;
}
export interface StarkwareOraclePrice {
    signedAssetId: string;
    signedPrice: string;
    expirationEpochSeconds: number;
}
export {};
