"use strict";
/**
 * Unit tests for signable/withdrawal.ts.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const expect_1 = __importDefault(require("expect"));
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("../../src/types");
const keys_1 = require("../../src/keys");
const helpers_1 = require("../../src/helpers");
const util_1 = require("../util");
// Module under test.
const withdrawal_1 = require("../../src/signable/withdrawal");
// Mock params.
const mockKeyPair = {
    publicKey: '3b865a18323b8d147a12c556bfb1d502516c325b1477a23ba6c77af31f020fd',
    privateKey: '58c7d5a90b1776bde86ebac077e053ed85b0f7164f53b080304a531947f46e3',
};
const mockWithdrawal = {
    positionId: '12345',
    humanAmount: '49.478023',
    expirationIsoTimestamp: '2020-09-17T04:15:55.028Z',
    clientId: 'This is an ID that the client came up with to describe this withdrawal',
};
const mockSignature = ('05e48c33f8205a5359c95f1bd7385c1c1f587e338a514298c07634c0b6c952ba' +
    '0687d6980502a5d7fa84ef6fdc00104db22c43c7fb83e88ca84f19faa9ee3de1');
describe('SignableWithdrawal', () => {
    describe('verifySignature()', () => {
        it('returns true for a valid signature', async () => {
            const result = await withdrawal_1.SignableWithdrawal
                .fromWithdrawal(mockWithdrawal, types_1.NetworkId.ROPSTEN)
                .verifySignature(mockSignature, mockKeyPair.publicKey);
            (0, expect_1.default)(result).toBe(true);
        });
        it('returns false for an invalid signature', async () => {
            // Mutate a single character in r.
            await Promise.all(lodash_1.default.range(1, 4).map(async (i) => {
                const badSignature = (0, util_1.mutateHexStringAt)(mockSignature, i);
                const result = await withdrawal_1.SignableWithdrawal
                    .fromWithdrawal(mockWithdrawal, types_1.NetworkId.ROPSTEN)
                    .verifySignature(badSignature, mockKeyPair.publicKey);
                (0, expect_1.default)(result).toBe(false);
            }));
            // Mutate a single character in s.
            await Promise.all(lodash_1.default.range(1, 4).map(async (i) => {
                const badSignature = (0, util_1.mutateHexStringAt)(mockSignature, i + 64);
                const result = await withdrawal_1.SignableWithdrawal
                    .fromWithdrawal(mockWithdrawal, types_1.NetworkId.ROPSTEN)
                    .verifySignature(badSignature, mockKeyPair.publicKey);
                (0, expect_1.default)(result).toBe(false);
            }));
        });
    });
    describe('sign()', () => {
        it('signs a withdrawal', async () => {
            const signature = await withdrawal_1.SignableWithdrawal
                .fromWithdrawal(mockWithdrawal, types_1.NetworkId.ROPSTEN)
                .sign(mockKeyPair.privateKey);
            (0, expect_1.default)(signature).toEqual(mockSignature);
        });
        it('signs a withdrawal with nonce instead of clientId', async () => {
            const withdrawalWithNonce = {
                ...mockWithdrawal,
                clientId: undefined,
                nonce: (0, helpers_1.nonceFromClientId)(mockWithdrawal.clientId),
            };
            const signature = await withdrawal_1.SignableWithdrawal
                .fromWithdrawalWithNonce(withdrawalWithNonce, types_1.NetworkId.ROPSTEN)
                .sign(mockKeyPair.privateKey);
            (0, expect_1.default)(signature).toEqual(mockSignature);
        });
        it('generates a different signature when the client ID is different', async () => {
            const withdrawal = {
                ...mockWithdrawal,
                clientId: `${mockWithdrawal.clientId}!`,
            };
            const signature = await withdrawal_1.SignableWithdrawal
                .fromWithdrawal(withdrawal, types_1.NetworkId.ROPSTEN)
                .sign(mockKeyPair.privateKey);
            (0, expect_1.default)(signature).not.toEqual(mockSignature);
        });
        it('generates a different signature when the position ID is different', async () => {
            const withdrawal = {
                ...mockWithdrawal,
                positionId: (Number.parseInt(mockWithdrawal.positionId, 10) + 1).toString(),
            };
            const signature = await withdrawal_1.SignableWithdrawal
                .fromWithdrawal(withdrawal, types_1.NetworkId.ROPSTEN)
                .sign(mockKeyPair.privateKey);
            (0, expect_1.default)(signature).not.toEqual(mockSignature);
        });
    });
    describe('toStarkware()', () => {
        it('converts human amounts to quantum amounts and converts expiration to hours', () => {
            const starkwareWithdrawal = withdrawal_1.SignableWithdrawal
                .fromWithdrawal(mockWithdrawal, types_1.NetworkId.ROPSTEN)
                .toStarkware();
            (0, expect_1.default)(starkwareWithdrawal.quantumsAmount).toBe('49478023');
            (0, expect_1.default)(starkwareWithdrawal.expirationEpochHours).toBe(444533);
        });
    });
    it('end-to-end', async () => {
        // Repeat some number of times.
        await Promise.all(lodash_1.default.range(3).map(async () => {
            const keyPair = (0, keys_1.generateKeyPairUnsafe)();
            const signableWithdrawal = withdrawal_1.SignableWithdrawal.fromWithdrawal(mockWithdrawal, types_1.NetworkId.ROPSTEN);
            const signature = await signableWithdrawal.sign(keyPair.privateKey);
            // Expect to be valid when verifying with the right public key.
            (0, expect_1.default)(await signableWithdrawal.verifySignature(signature, keyPair.publicKey)).toBe(true);
            // Expect to be invalid when verifying with a different public key.
            (0, expect_1.default)(await signableWithdrawal.verifySignature(signature, mockKeyPair.publicKey)).toBe(false);
        }));
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l0aGRyYXdhbC50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vX190ZXN0c19fL3NpZ25hYmxlL3dpdGhkcmF3YWwudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7O0FBRUgsb0RBQTRCO0FBQzVCLG9EQUF1QjtBQUV2QiwyQ0FNeUI7QUFDekIseUNBQXVEO0FBQ3ZELCtDQUFzRDtBQUN0RCxrQ0FBNEM7QUFFNUMscUJBQXFCO0FBQ3JCLDhEQUFtRTtBQUVuRSxlQUFlO0FBQ2YsTUFBTSxXQUFXLEdBQVk7SUFDM0IsU0FBUyxFQUFFLGlFQUFpRTtJQUM1RSxVQUFVLEVBQUUsaUVBQWlFO0NBQzlFLENBQUM7QUFDRixNQUFNLGNBQWMsR0FBMkI7SUFDN0MsVUFBVSxFQUFFLE9BQU87SUFDbkIsV0FBVyxFQUFFLFdBQVc7SUFDeEIsc0JBQXNCLEVBQUUsMEJBQTBCO0lBQ2xELFFBQVEsRUFBRSx3RUFBd0U7Q0FDbkYsQ0FBQztBQUNGLE1BQU0sYUFBYSxHQUFHLENBQ3BCLGtFQUFrRTtJQUNsRSxrRUFBa0UsQ0FDbkUsQ0FBQztBQUVGLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7SUFFbEMsUUFBUSxDQUFDLG1CQUFtQixFQUFFLEdBQUcsRUFBRTtRQUVqQyxFQUFFLENBQUMsb0NBQW9DLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDbEQsTUFBTSxNQUFNLEdBQUcsTUFBTSwrQkFBa0I7aUJBQ3BDLGNBQWMsQ0FBQyxjQUFjLEVBQUUsaUJBQVMsQ0FBQyxPQUFPLENBQUM7aUJBQ2pELGVBQWUsQ0FBQyxhQUFhLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3pELElBQUEsZ0JBQU0sRUFBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsd0NBQXdDLEVBQUUsS0FBSyxJQUFJLEVB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